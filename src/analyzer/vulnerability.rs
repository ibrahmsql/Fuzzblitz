#![allow(dead_code)]
use regex::Regex;
use std::collections::HashMap;

/// Scan for common vulnerabilities
pub struct VulnerabilityScanner {
    signatures: HashMap<VulnerabilityType, Vec<Regex>>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum VulnerabilityType {
    SQLInjection,
    XSS,
    PathTraversal,
    CommandInjection,
    XXE,
    SSRF,
    OpenRedirect,
    InfoDisclosure,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityFinding {
    pub vuln_type: VulnerabilityType,
    pub confidence: f32,
    pub evidence: String,
    pub description: String,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        let mut scanner = Self {
            signatures: HashMap::new(),
        };
        scanner.load_signatures();
        scanner
    }
    
    fn load_signatures(&mut self) {
        // SQL Injection signatures
        self.add_signature(
            VulnerabilityType::SQLInjection,
            vec![
                r"(?i)SQL syntax.*MySQL",
                r"(?i)Warning.*mysql_",
                r"(?i)valid MySQL result",
                r"(?i)MySqlClient\.",
                r"(?i)PostgreSQL.*ERROR",
                r"(?i)Warning.*\Wpg_",
                r"(?i)valid PostgreSQL result",
                r"(?i)Npgsql\.",
                r"(?i)Driver.* SQL[\-\_\ ]*Server",
                r"(?i)OLE DB.* SQL Server",
                r"(?i)\bORA-[0-9][0-9][0-9][0-9]",
                r"(?i)Oracle error",
                r"(?i)Oracle.*Driver",
            ],
        );
        
        // XSS signatures
        self.add_signature(
            VulnerabilityType::XSS,
            vec![
                r"<script[^>]*>.*</script>",
                r"javascript:",
                r"onerror\s*=",
                r"onload\s*=",
            ],
        );
        
        // Path Traversal
        self.add_signature(
            VulnerabilityType::PathTraversal,
            vec![
                r"(?i)Failed opening.*for inclusion",
                r"(?i)Warning.*include\(",
                r"(?i)Warning.*require\(",
            ],
        );
        
        // Command Injection
        self.add_signature(
            VulnerabilityType::CommandInjection,
            vec![
                r"uid=\d+\(.*\) gid=\d+\(.*\)",
                r"root:.*:0:0:",
            ],
        );
        
        // Info Disclosure
        self.add_signature(
            VulnerabilityType::InfoDisclosure,
            vec![
                r"(?i)Stack trace:",
                r"(?i)Exception:",
                r"(?i)at line \d+ in file",
            ],
        );
    }
    
    fn add_signature(&mut self, vuln_type: VulnerabilityType, patterns: Vec<&str>) {
        let regexes: Vec<Regex> = patterns
            .iter()
            .filter_map(|p| Regex::new(p).ok())
            .collect();
        
        self.signatures.insert(vuln_type, regexes);
    }
    
    /// Scan response for vulnerabilities
    pub fn scan(&self, response_body: &str, _status_code: u16) -> Vec<VulnerabilityFinding> {
        let mut findings = Vec::new();
        
        for (vuln_type, regexes) in &self.signatures {
            for regex in regexes {
                if let Some(matched) = regex.find(response_body) {
                    findings.push(VulnerabilityFinding {
                        vuln_type: vuln_type.clone(),
                        confidence: 0.7,
                        evidence: matched.as_str().to_string(),
                        description: self.get_description(vuln_type),
                    });
                }
            }
        }
        
        findings
    }
    
    fn get_description(&self, vuln_type: &VulnerabilityType) -> String {
        match vuln_type {
            VulnerabilityType::SQLInjection => "Possible SQL Injection vulnerability detected".to_string(),
            VulnerabilityType::XSS => "Possible Cross-Site Scripting (XSS) vulnerability detected".to_string(),
            VulnerabilityType::PathTraversal => "Possible Path Traversal vulnerability detected".to_string(),
            VulnerabilityType::CommandInjection => "Possible Command Injection vulnerability detected".to_string(),
            VulnerabilityType::XXE => "Possible XML External Entity (XXE) vulnerability detected".to_string(),
            VulnerabilityType::SSRF => "Possible Server-Side Request Forgery (SSRF) vulnerability detected".to_string(),
            VulnerabilityType::OpenRedirect => "Possible Open Redirect vulnerability detected".to_string(),
            VulnerabilityType::InfoDisclosure => "Information Disclosure detected".to_string(),
        }
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}
